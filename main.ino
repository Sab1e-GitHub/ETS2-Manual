#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
// Bitmap data (replace this with your own data)
static const unsigned char bitmap_bytes[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x03, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x80, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x1f, 0xf0, 0x00, 0x7f, 0xc0, 0x01, 0xff, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x3f, 0xf8, 0x00, 0xff, 0xe0, 0x03, 0xff, 0x80, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x7f, 0xfc, 0x01, 0xff, 0xf0, 0x07, 0xff, 0xc0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x7f, 0xfc, 0x01, 0xff, 0xf0, 0x07, 0xff, 0xc0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xff, 0xfe, 0x03, 0xff, 0xf8, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xff, 0xfe, 0x03, 0xff, 0xf8, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xff, 0xfe, 0x03, 0xff, 0xf8, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xff, 0xfe, 0x03, 0xff, 0xf8, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xff, 0xfe, 0x03, 0xff, 0xf8, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x7f, 0xfc, 0x01, 0xff, 0xf0, 0x07, 0xff, 0xc0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x7f, 0xfc, 0x01, 0xff, 0xf0, 0x07, 0xff, 0xc0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x3f, 0xf8, 0x00, 0xff, 0xe0, 0x03, 0xff, 0x80, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x1f, 0xf0, 0x00, 0x7f, 0xc0, 0x01, 0xff, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x01, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x01, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x01, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x01, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x01, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x1f, 0xf0, 0x00, 0x7f, 0xc0, 0x01, 0xff, 0x00, 0x07, 0xfc, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x3f, 0xf8, 0x00, 0xff, 0xe0, 0x03, 0xff, 0x80, 0x0f, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x7f, 0xfc, 0x01, 0xff, 0xf0, 0x07, 0xff, 0xc0, 0x1f, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x7f, 0xfc, 0x01, 0xff, 0xf0, 0x07, 0xff, 0xc0, 0x1f, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xff, 0xfe, 0x03, 0xff, 0xf8, 0x0f, 0xff, 0xe0, 0x3f, 0xff, 0x83, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xff, 0xfe, 0x03, 0xff, 0xf8, 0x0f, 0xff, 0xe0, 0x3f, 0xff, 0x83, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xff, 0xfe, 0x03, 0xff, 0xf8, 0x0f, 0xff, 0xe0, 0x3f, 0xff, 0x83, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xff, 0xfe, 0x03, 0xff, 0xf8, 0x0f, 0xff, 0xe0, 0x3f, 0xff, 0x83, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xff, 0xfe, 0x03, 0xff, 0xf8, 0x0f, 0xff, 0xe0, 0x3f, 0xff, 0x83, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x7f, 0xfc, 0x01, 0xff, 0xf0, 0x07, 0xff, 0xc0, 0x1f, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x7f, 0xfc, 0x01, 0xff, 0xf0, 0x07, 0xff, 0xc0, 0x1f, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x3f, 0xf8, 0x00, 0xff, 0xe0, 0x03, 0xff, 0x80, 0x0f, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x1f, 0xf0, 0x00, 0x7f, 0xc0, 0x01, 0xff, 0x00, 0x07, 0xfc, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xc0, 0x00, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x01, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xe0, 0x00, 0x10, 0x80, 0x00, 0x7e, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x20, 0x00, 0x10, 0x80, 0x00, 0x40, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x20, 0x00, 0x10, 0x80, 0x00, 0x40, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xe0, 0x00, 0x1f, 0x80, 0x00, 0x7e, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x00, 0x42, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x00, 0x42, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0xe0, 0x00, 0x00, 0x80, 0x00, 0x7e, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


const int keyUp = 2;     // D2引脚
const int keyDown = 3;   // D3引脚
const int keyLeft = 4;   // D4引脚
const int keyRight = 5;  // D5引脚

const unsigned long debounceDelay = 50;  // 软件消抖延迟（毫秒）

unsigned long lastDebounceTimeUp = 0;
unsigned long lastDebounceTimeDown = 0;
unsigned long lastDebounceTimeLeft = 0;
unsigned long lastDebounceTimeRight = 0;

bool keyReleased = true;        // 状态变量，跟踪当前是否已发送松开按键的指令
bool lastKeyUpState = HIGH;     // 上一个按键状态
bool lastKeyDownState = HIGH;   // 上一个按键状态
bool lastKeyLeftState = HIGH;   // 上一个按键状态
bool lastKeyRightState = HIGH;  // 上一个按键状态

int currentX_position=37;
int currentY_position=32;

void displayPosition(int x,int y){
  display.clearDisplay();
  // Draw the bitmap
  display.drawBitmap(0, 0, bitmap_bytes, SCREEN_WIDTH, SCREEN_HEIGHT, WHITE);

  display.fillCircle(x, y, 7, WHITE); // x, y, 半径, 颜色
  display.fillCircle(x, y, 5, BLACK); // x, y, 半径, 颜色
  display.display(); // 更新显示
}
void displayString(const char str[]){
  display.setTextSize(4);  // 字体大小设置为1
  display.setTextColor(WHITE);  // 字体颜色设置为白色
  
  // 设置文字位置
  display.setCursor(100, 18);  // 设置文字开始坐标
  
  // 打印数字
  display.print(str);
  
  // 更新显示
  display.display();
}
void setup() {
  Serial.begin(9600);

  pinMode(keyUp, INPUT_PULLUP);
  pinMode(keyDown, INPUT_PULLUP);
  pinMode(keyLeft, INPUT_PULLUP);
  pinMode(keyRight, INPUT_PULLUP);

  // Initialize the display
  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
      Serial.println(F("SSD1306 allocation failed"));
      for (;;); // Don't proceed, loop forever
  }
  displayPosition(currentX_position,currentY_position);
  displayString("N");
}


bool isButtonPressed(int pin, unsigned long &lastDebounceTime) {
  int buttonState = digitalRead(pin);
  if (buttonState == LOW) {
    unsigned long currentTime = millis();
    if ((currentTime - lastDebounceTime) > debounceDelay) {
      lastDebounceTime = currentTime;
      return true;
    }
  }
  return false;
}

uint8_t calculateChecksum(uint8_t *data, size_t length) {
  uint8_t sum = 0;
  for (size_t i = 0; i < length; i++) {
    sum += data[i];
  }
  return sum;
}

void sendKeyPress(uint8_t keyCode) {
  uint8_t packet[] = { 0x57, 0xAB, 0x00, 0x02, 0x08, 0x00, 0x00, 0x00, keyCode, 0x00, 0x00, 0x00, 0x00, 0x00 };
  packet[13] = calculateChecksum(packet, 13);
  Serial.write(packet, sizeof(packet));
  keyReleased = false;
}

void sendKeyRelease() {
  uint8_t packet[] = { 0x57, 0xAB, 0x00, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
  packet[13] = calculateChecksum(packet, 13);
  Serial.write(packet, sizeof(packet));
  keyReleased = true;
}

uint8_t gearShiftArray[3][4] = {
  { 0, 0, 0, 0 },
  { 0, 1, 0, 0 },
  { 0, 0, 0, 0 }
};

int currentX = 1;  // 1的初始位置
int currentY = 1;

uint8_t getGearCode(uint8_t x, uint8_t y) {
  // 根据档位坐标返回相应的小键盘键码
  if (x == 0 && y == 0) {
    displayString("1");
    return 0x59;  // 1
  }
  if (x == 0 && y == 1) {
    displayString("3");
    return 0x5B;  // 3
  }
  if (x == 0 && y == 2) {
    displayString("5");
    return 0x5D;  // 5
  }
  if (x == 2 && y == 0)  {
    displayString("2");
    return 0x5A;  // 2
  }
  if (x == 2 && y == 1)  {
    displayString("4");
    return 0x5C;  // 4
  }
  if (x == 2 && y == 2)  {
    displayString("6");
    return 0x5E;  // 6
  }
  if (x == 2 && y == 3)  {
    displayString("R");
    return 0x62;  // R, 小键盘0
  }
  displayString("N");
  return 0x00;                     // N或无效档位
}

void checkGearAndSendKey() {
  uint8_t keyCode = getGearCode(currentX, currentY);


  if (keyCode != 0x00) {
    sendKeyPress(keyCode);

  } else {
    if(!keyReleased){
      sendKeyRelease();
    }
  }
}
void loop() {
  // 检查每个按钮，并处理状态变化
  if (isButtonPressed(keyUp, lastDebounceTimeUp)) {
    if (lastKeyUpState == HIGH) {  // 仅在状态改变时执行
      if (currentX > 0 && gearShiftArray[currentX - 1][currentY] == 0 && !(currentX == 1 && currentY == 3)) {
        gearShiftArray[currentX][currentY] = 0;
        currentX--;
        gearShiftArray[currentX][currentY] = 1;
        lastKeyUpState = LOW;  // 更新状态
        currentY_position-=15;
        displayPosition(currentX_position,currentY_position);
        //Serial.println("UP");
      }
    }
  } else {
    lastKeyUpState = HIGH;  // 按钮释放时更新状态
  }

  if (isButtonPressed(keyDown, lastDebounceTimeDown)) {
    if (lastKeyDownState == HIGH) {
      if (currentX < 2 && gearShiftArray[currentX + 1][currentY] == 0) {
        gearShiftArray[currentX][currentY] = 0;
        currentX++;
        gearShiftArray[currentX][currentY] = 1;
        lastKeyDownState = LOW;  // 更新状态
        currentY_position+=15;
        displayPosition(currentX_position,currentY_position);
        //Serial.println("DOWN");
      }
    }
  } else {
    lastKeyDownState = HIGH;  // 按钮释放时更新状态
  }

  if (isButtonPressed(keyLeft, lastDebounceTimeLeft)) {
    if (lastKeyLeftState == HIGH) {
      if (currentY > 0 && gearShiftArray[currentX][currentY - 1] == 0 && currentX != 0 && currentX != 2) {
        gearShiftArray[currentX][currentY] = 0;
        currentY--;
        gearShiftArray[currentX][currentY] = 1;
        lastKeyLeftState = LOW;  // 更新状态
        currentX_position-=22;
        displayPosition(currentX_position,currentY_position);
        //Serial.println("LEFT");
      }
    }
  } else {
    lastKeyLeftState = HIGH;  // 按钮释放时更新状态
  }

  if (isButtonPressed(keyRight, lastDebounceTimeRight)) {
    if (lastKeyRightState == HIGH) {
      if (currentY < 3 && gearShiftArray[currentX][currentY + 1] == 0 && currentX != 0 && currentX != 2) {
        gearShiftArray[currentX][currentY] = 0;
        currentY++;
        gearShiftArray[currentX][currentY] = 1;
        lastKeyRightState = LOW;  // 更新状态
        currentX_position+=22;
        displayPosition(currentX_position,currentY_position);
        //Serial.println("RIGHT");
      }
    }
  } else {
    lastKeyRightState = HIGH;  // 按钮释放时更新状态
  }

  checkGearAndSendKey();
  delay(100);  // 延时以避免过于频繁的按键发送
}
